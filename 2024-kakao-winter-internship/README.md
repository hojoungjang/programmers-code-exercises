# Retro
전반적으로 생각보다 어려웠다.

레벨 3 문제에서는 엣지 케이스에 걸리는 경우가 많고, optimization 하는 부분에서 자주 막혔다.

## 가장 많이 받은 선물 - Lv 1
[가장 많이 받은 선물](https://school.programmers.co.kr/learn/courses/30/lessons/258712)
직관적이다. 주어진 인풋 데이터를 토대로 계산을 하고 조건에 맞춰 값을 찾는 문제이다.

좀 고민했던 부분은 어떤 데이터 처리 과정을 어떻게 작성할지 였다. 원하는 값을 얻기 위해
* 어떤 자료구조를 사용할지?
* 어떤 데이터를 보관해야 할지?
오랜만에 해서 그런지 생각보다 고민하는 시간이 길어졌고 정리를 잘 안하고 시작해서 그런지 코드 구현이 오래걸렸다.

조건 부분에서 한번 틀렸다. 문제를 보면 첫번째 조건에서 사용하는 비교 값이 같을때 두번째 조건 검사를 해야하는데
비교 값이 작은 상황에도 두번째 조건을 실행해버렸다.

한번 풀고 다시 처음부터 작성해 보았는데 좀 더 개인적으로 마음에드는 간결함으로 작성이 됬다.
구현이 쉬운 문제는 빠르게 풀고 나서 다시 보는게 효율적일 수 도 있겠다.

## 도넛과 막대 그래프
[도넛과 막대 그래프](https://school.programmers.co.kr/learn/courses/30/lessons/258711)

생각보다 문제를 이해하고 방향을 잡는데 오래걸렸다.

들어본적 없는 "땡땡" 모양 그래프를 얘기하는데 뭔가 여기서 당한 느낌이기도 하다.
설명을 읽는것 과정 조차 벅차다.

일단 문제에서 원하는 값: 시작 노드, 도넛 그래프 개수, 막대 그래프 개수 그리고 8자 그래프 개수에서
시작 노드부터 어떻게 구할 수 있을지 생각해보았다.

각 그래프의 특징을 보고 예제에 있는 시작 노드의 특징과 문제의 조건 (constraint) 들을 보다가 결국에는
시작노드의 패턴을 찾았다. inward edge 가 없고 outward edge 가 두개 이상

그리고 나면 시작노드와 연결된 서브 그래프들을 하나씩 살펴보면서 각각 노드와 엣지의 수를 구해 어떤 유형의 그래프인지 
찾았다. 문제에서 도넛, 막대, 8자 그래프의 노드와 엣지수를 명시했기 때문에 이 조건에 맞추면 된다.

중간에 제출이 계속 런타임 에러가 나서 막혔었는데, 알고보니 recursion depth 를 초과했다. Python 은 1000 이
default 이기 때문에 엣지의 개수가 최대 1,000,000 인 이 문제에서는 부족하다. 한창 문제 많이 풀때는 자동으로 반응했던것같은데
오랜만에 하니까 런타임에러 원인이 뭔지 감도 오지 않았다.

## 주사위 고르기
[주사위 고르기](https://school.programmers.co.kr/learn/courses/30/lessons/258709)

처음에는 모든 경우에 수를 구해서 가장 이기는 횟수가 많은 경우를 찾았다. 

일단 시간복잡도를 분석해서 어떻게 최적화 할지 생각해보려 했지만 시간 복잡도를 알아내는게 너무 헷갈렸고
모든 경우의수를 비교하는 brute-force 시간 복잡도에서 어디를 최적화 할 수 있을지 및 타겟 시간복잡도에
대한 접근을 잘 하지 못 했다.

아쉽게도 질문섹션에 힌트를 참고해 이분탐색을 사용해서 억지로 푼 느낌이었다.

## n + 1 카드게임
[n + 1 카드게임](https://school.programmers.co.kr/learn/courses/30/lessons/258707)

이 문제도 처음에는 모든 경우의 수를 다 찾아서 정답을 구했다.

Optimize 하는 과정에서 greedy 방식 비슷하게 나만의 알고리즘을 세워봤지만 모든 엣지 케이스를 잡지 못했다.
힌트를 참고해 버려진 카드도 보관을 해두었다가 필요시 사용하는 접근이 필요하다는걸 이용해 다시 작성해 풀었다.

결론은 처음에 시작하는 카드들은 각 라운드에서 매칭이 가능하다면 무조건 매칭을 해준다. 이 행동은 코인을 사용하긴
하지만, 매칭을 수행하지 않으면 어차피 마지막까지 사용이 불가능하다. 각 카드 숫자는 unique 하기 때문에 해당 카드와
매칭될수 있는 카드는 딱 하나이다.

그리고 나서 만약 들고 있는 카드에서 적어도 하나의 쌍이 있으면 다음 라운드로 넘어가고, 사용하지 않은 카드는 
버려진 카드 덱에 넣어서 따로 자료구조를 사용해 트랙한다.

만약 아직 다음 라운드로 넘어가기 위한 한 쌍을 만들지 못했으면, 버려진 카드 덱에서 현재 라운드의 새로운 카드와
조합이 가능한지 확인해서 사용한다. 이때 코인은 적어도 두개 이상있을때만 버려진 카드랑 매칭이 가능하다.

실제 게임에서는 버려진 카드는 사용할 수 없지만, 우리는 best case 를 알고 싶은것이기 때문에 최고의 상황을 연출할 수 있는
방법을 사용하는 것이다.

이렇게 하면 linear time 으로 솔루션을 최적화 할 수 있다.

## 총평
느끼는 점
1. 설명에 너무 현혹되지 마라
   * 너무 구현이 설명에 절여진다
   * 가끔 예제 설명을 보고 하나의 케이스에만 집중하게 될 수 있다
2. 엣지 케이스가 무수하다 (보통 lv1 제외)
3. 완전 탐색 + 다이내믹 프로그래밍 위주 (lv 3 이상) optimize 하는게 어렵다. 보통 아직은 하기 힘든 thinking 을 요구한다.

의문
1. 타이핑을 하면 좋을까 (속도를 포기하고 타이핑을 하면 그만큼 코드를 보거나 짤때 덜 헷갈리거나 디버깅이 쉬울까?)
2. 어떤식으로 접근해야 속도를 낼 수 있을까?
